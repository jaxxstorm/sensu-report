#!/usr/bin/env python
"""
Prints a human readable output of the failing Sensu checks into your
terminal.  Queries the Sensu API and formats it into pretty colors. Basically
a text based report of the sensu dashboard, on a particular client. (by
default, the local hostmame)
"""

from datetime import datetime
from optparse import OptionParser
import re
import socket
import sys
import time
import urllib2


try:
    import json
except ImportError:
    import simplejson as json


RED = '\033[91m'
YELLOW = '\033[93m'
GREY = '\033[90m'
GREEN = '\033[92m'
PURPLE = '\033[95m'
CLEAR = '\033[0m'


def make_parse():
    parser = OptionParser()
    parser.add_option("-s", "--server", dest="server",
                      help="sensu api server hostname")
    max_line_default = 80
    parser.add_option(
        "-l", "--length", dest="max_line_length", default=max_line_default,
        help="longest line length for the output acceptable. Defaults to your terminal width")
    parser.add_option(
        "-p", "--port", dest="port",
        help="sensu server api port", default=4567)
    parser.add_option(
        "-c", "--client", dest="client", default=False,
        help="hostname of the client to get the report on. Defaults to the local fqdn.")
    parser.add_option(
        "-U", "--user", dest="user", default=False,
        help="Username to use for api basic auth. Defaults to false.")
    parser.add_option(
        "-P", "--password", dest="password", default=False,
        help="Password to use for api basic auth. Defaults to false.")
    return parser


def fetch_sensu_data(server, port, client, username, password):
    """ Connects to the Sensu API over a given host and port, and returns
    dictionary based on the retrieved json data. """
    base_url = 'http://' + server + ':' + str(port)
    api_url = base_url + '/events/' + client
    try:
        if username:
            password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
            password_mgr.add_password(
                realm=None,
                uri=base_url,
                user=username,
                passwd=password)
            auth_handler = urllib2.HTTPBasicAuthHandler(password_mgr)
            opener = urllib2.build_opener(auth_handler)
            urllib2.install_opener(opener)
        response = urllib2.urlopen(api_url)
    except:
        print "Fetching the Sensu API url didn't work:"
        print api_url
        raise
    data = json.load(response)
    return data

def check_client_exists(server, port, client, username, password):
    """ Connects to the Sensu API over a given host and port, and returns
    the http response code meaning we can determine if client exists. """
    base_url = 'http://' + server + ':' + str(port)
    api_url = base_url + '/clients/' + client
    try:
        if username:
            password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
            password_mgr.add_password(
                realm=None,
                uri=base_url,
                user=username,
                passwd=password)
            auth_handler = urllib2.HTTPBasicAuthHandler(password_mgr)
            opener = urllib2.build_opener(auth_handler)
            urllib2.install_opener(opener)
        response = urllib2.urlopen(api_url)
    except urllib2.HTTPError, e:
        return e.code
    except:
          print "Fetching the Sensu API Url didn't work:"
          print api_url
          raise
    if response:
      result = response.getcode()
    return result


def fetch_silence_data(server, port, client, username, password):
    """ Connects to the Sensu API over a given host and port, and returns
    dictionary based on the retrieved json for the stash. """
    stash_url = 'http://' + server + ':' + str(port) + '/stashes/silence/' + client
    try:
        if username:
            auth_handler = urllib2.HTTPBasicAuthHandler()
            auth_handler.add_password(
                realm='',
                uri='http://' + server + ':' + str(port) + '/',
                user=username,
                passwd=password)
            opener = urllib2.build_opener(auth_handler)
            urllib2.install_opener(opener)
        response = urllib2.urlopen(stash_url)
    except urllib2.HTTPError:
        return {}
    except:
        print "Fetching the Sensu API url didn't work:"
        print 'http://' + server + ':' + str(port) + '/events/' + client
        raise
    data = json.load(response)
    return data


def test_pretty_date():
    """ Lets put in some epochs we expect from sensu and make sure it is pretty
    """
    fakenow = int(time.time()-5)
    assert pretty_date(fakenow) == "Just now"


def pretty_date(time=False):
    """ Get a datetime object or a int() Epoch timestamp and return a pretty
    string like 'an hour ago', 'Yesterday', '3 months ago', 'just now', etc """
    now = datetime.now()
    if type(time) is int:
        diff = now - datetime.fromtimestamp(time)
    elif isinstance(time, datetime):
        diff = now - time
    elif not time:
        diff = now - now
    else:
        diff = now - now
    second_diff = diff.seconds
    day_diff = diff.days

    if day_diff < 0:
        return ''

    if day_diff == 0:
        if second_diff < 10:
            return "just now"
        if second_diff < 60:
            return str(second_diff) + " seconds ago"
        if second_diff < 120:
            return "a minute ago"
        if second_diff < 3600:
            return str(second_diff / 60) + " minutes ago"
        if second_diff < 7200:
            return "an hour ago"
        if second_diff < 86400:
            return str(second_diff / 3600) + " hours ago"
    if day_diff == 1:
        return "Yesterday"
    if day_diff < 7:
        return str(day_diff) + " days ago"
    if day_diff < 31:
        return str(day_diff/7) + " weeks ago"
    if day_diff < 365:
        return str(day_diff/30) + " months ago"
    return str(day_diff/365) + " years ago"


def sanitize_sensu_output(line, length):
    """The output of sensu plugins are unpredictable. They could have newlines,
    ANSI color codes, html, etc. This function returns a stripped string. It
    also will limit the output of the string to prevent console overflow."""
    line = line.replace("\n", " ")
    ansi_escape = re.compile(r'\x1b[^m]*m')
    line = ansi_escape.sub('', line)
    if len(line) > length:
        line = line[:length-3] + "..."
    return line


def print_line(entry, max_line_length):
    """Formats a colored line based on the provided sensu entry dictionary"""
    if entry['check']['status'] == 2:
        color = RED
        severity = "Crit: "
    elif entry['check']['status'] == 1:
        color = YELLOW
        severity = "Warn: "
    else:
        color = GREY
        severity = "Unkn: "
    line = " " + color + severity + " " + entry['check']['name'] + ': ' + CLEAR
    # We add 7 because the line length is artificially long because of the
    # colors And we want a margin on the right hand side. TODO: fix
    stripped_output = sanitize_sensu_output(entry['check']['output'], max_line_length-len(line) + 7)
    sys.stdout.write(line + stripped_output)
    print


def print_report(data, max_line_length, http_code):
    """Prints a human readable report based on the sensu data"""
    print
    # we only want to show events when client exists
    if http_code == 200:
      if len(data) > 0:
        print "Don't Panic! Ops already knows! Failed Sensu checks on this host:"
        # Criticals
        for entry in sorted([x for x in data if x['check']['status'] == 2]):
            print_line(entry, max_line_length)
        # Warning
        for entry in sorted([x for x in data if x['check']['status'] == 1]):
            print_line(entry, max_line_length)
        # Unknown
        for entry in sorted([x for x in data if x['check']['status'] != 2 and x['check']['status'] != 1]):
            print_line(entry, max_line_length)
      else:
          print "All Sensu checks " + GREEN + "green " + CLEAR + "for this host."
    else:
      print YELLOW + "This client" + CLEAR + " doesn't exist in Sensu"
    print


def print_silence_report(silence_data, max_line_length):
    if silence_data != {}:
        if 'timestamp' in silence_data:
            print "Notice: " + PURPLE + "This server was silenced " + pretty_date(silence_data['timestamp']) + CLEAR
        else:
            print "Notice: " + PURPLE + "This server is silenced." + CLEAR
        if 'reason' in silence_data:
            print "Reason: " + PURPLE + silence_data['reason'] + CLEAR


def main():
    parser = make_parse()
    (options, args) = parser.parse_args()
    options.max_line_length = int(options.max_line_length)
    if not options.client:
        options.client = socket.getfqdn()
    if not options.server:
        print "Error: No sensu server provided."
        parser.print_help()
        sys.exit(1)
    silence_data = fetch_silence_data(
        options.server, options.port, options.client,
        options.user, options.password)
    print_silence_report(silence_data, options.max_line_length)
    http_code = check_client_exists(
        options.server, options.port, options.client,
        options.user, options.password)
    events = fetch_sensu_data(
        options.server, options.port, options.client,
        options.user, options.password)
    print_report(events, options.max_line_length, http_code)


if __name__ == '__main__':
    main()
